package io.timparsons.dropwizard.views.config;

import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

import com.google.common.collect.ImmutableMap;

import io.timparsons.dropwizard.views.config.LocaleMap.LocaleMapValue;

public class LocaleMap implements Map<String, LocaleMapValue> {

    private ImmutableMap<String, LocaleMapValue> internalMap;

    private LocaleMap() {
    }

    private LocaleMap(final ImmutableMap<String, LocaleMapValue> map) {
        if (this.internalMap == null) {
            this.internalMap = map;
        }
    }

    public static class Builder {
        private Map<String, LocaleMapValue> builderMap;

        /**
         * Creates a new builder. The returned builder is equivalent to the
         * builder generated by {@link ImmutableMap#builder}.
         */
        public Builder() {
            builderMap = new HashMap<>();
        }

        /**
         * Associates {@code key} with {@code value} in the built map. Duplicate
         * keys are not allowed, and will cause {@link #build} to fail.
         */
        public Builder put(final String key, final LocaleMapValue value) {
            builderMap.put(key, value);
            return this;
        }

        /**
         * Adds the given {@code entry} to the map, making it immutable if
         * necessary. Duplicate keys are not allowed, and will cause
         * {@link #build} to fail.
         *
         * @since 11.0
         */
        public Builder put(final Entry<String, LocaleMapValue> entry) {
            return put(entry.getKey(), entry.getValue());
        }

        /**
         * Associates all of the given map's keys and values in the built map.
         *
         * @throws NullPointerException
         *             if any key or value in {@code map} is null
         */
        public Builder putAll(final Map<String, LocaleMapValue> map) {
            builderMap.putAll(map);

            return this;
        }


        /*
         * TODO(kevinb): Should build() and the ImmutableBiMap &
         * ImmutableSortedMap versions throw an IllegalStateException instead?
         */

        /**
         * Returns a newly-created immutable map.
         *
         * @throws IllegalArgumentException
         *             if duplicate keys were added
         */
        public LocaleMap build() {
            ImmutableMap.Builder<String, LocaleMapValue> imBuilder = ImmutableMap.builder();

            for (Entry<String, LocaleMapValue> entry : builderMap.entrySet()) {
                imBuilder.put(entry);
            }

            return new LocaleMap(imBuilder.build());
        }
    }

    public final static class LocaleMapValue {
        private final String value;

        public LocaleMapValue(final String value) {
            this.value = value;
        }

        public String params(final String... params) {
            String parameterizedString = this.value;

            for (int i = 0; i < params.length; i++) {
                parameterizedString = parameterizedString.replaceAll("\\{" + i + "\\}", params[i]);
            }

            return parameterizedString;
        }

        @Override
        public String toString() {
            return value;
        }
    }

    @Override
    public int size() {
        return internalMap.size();
    }

    @Override
    public boolean isEmpty() {
        return internalMap.isEmpty();
    }

    @Override
    public boolean containsKey(final Object key) {
        return internalMap.containsKey(key);
    }

    @Override
    public boolean containsValue(final Object value) {
        return internalMap.containsValue(value);
    }

    @Override
    public LocaleMapValue get(final Object key) {
        LocaleMapValue value = internalMap.get(key);
        if (value == null) {
            value = new LocaleMapValue("[" + key.toString() + "]");
        }

        return value;
    }

    @Deprecated
    @Override
    public LocaleMapValue put(final String key, final LocaleMapValue value) {
        throw new UnsupportedOperationException();
    }

    @Deprecated
    @Override
    public LocaleMapValue remove(final Object key) {
        throw new UnsupportedOperationException();
    }

    @Deprecated
    @Override
    public void putAll(final Map m) {
        throw new UnsupportedOperationException();
    }

    @Deprecated
    @Override
    public void clear() {
        throw new UnsupportedOperationException();
    }

    @Override
    public Set<String> keySet() {
        return internalMap.keySet();
    }

    @Override
    public Collection<LocaleMapValue> values() {
        return internalMap.values();
    }

    @Override
    public Set<java.util.Map.Entry<String, LocaleMapValue>> entrySet() {
        return internalMap.entrySet();
    }

    public static Builder builder() {
        return new Builder();
    }

}
